import { PDFDocument, PDFTextField, PDFCheckBox } from 'pdf-lib';
import { loadPdfFile, downloadFile } from '../utils/fileUtils';
import { gameData } from '../data/gameData';

// Helper function to format text by replacing underscores with spaces
const formatDisplayText = (text) => {
  if (!text) return text;
  return String(text).replace(/_/g, ' ');
};

// Helper function to get power cost based on power name
const getPowerCost = (powerName) => {
  // Handle multiple powers (comma-separated)
  const powers = powerName.split(',').map(p => p.trim());
  const costs = powers.map(power => {
    // No Cost Powers (Passive/Free)
    const noCostPowers = [
      'Amaranth', 'Beast Mind', 'Bestial Frenzy', 'Black Ichor', 'Clawed Form',
      'Cloak Sight', 'Cognizance', 'Test Vitae', 'Totemic Form', 'Toughness',
      'Umbra Sight', 'Venom Blood', 'Venomous Bite', 'Visions'
    ];
    
    // 1 Energy Cost
    const oneEnergyCost = [
      'Aggravated 1', 'Aggravated Claws', 'Appear', 'Avert', 'Beast Mind',
      'Body Wrack', 'Cloak', 'Cloak Gathering', 'Light Weapon', 'Medicine', 'Root',
      'Sanctuary', 'Sense Confidence', 'Sense Demon', 'True Form',
      'Umbra Strike', 'Weaponry', 'Wither', 'Withstand', 'Woadling', 'Wounding Lies'
    ];
    
    // 1 Willpower Cost
    const oneWillpowerCost = [
      'Avoidance', 'Materialize', 'Resist Taint', 'Revive'
    ];
    
    // 2 Energy Cost
    const twoEnergyCost = [
      'Balefire', 'Blood Buff', 'Brittle Bones', 'Brutal Strike',
      'Cleanse', 'Majesty', 'Mass Taunt', 'Venom'
    ];
    
    // 1 Virtue Cost
    const oneVirtueCost = [
      'Bestial Frenzy', 'Bestial Healing'
    ];
    
    // Special cases
    if (power === 'War Form') {
      return 'Req. 1+ Energy';
    }
    if (power === 'Weaponry' && /* targeting self */ false) {
      return 'No Cost'; // Special case: Weaponry costs no Energy if targeting self
    }
    
    // Check power against cost categories
    if (noCostPowers.includes(power)) {
      return 'No Cost';
    } else if (oneEnergyCost.includes(power)) {
      return '1 Energy';
    } else if (oneWillpowerCost.includes(power)) {
      return '1 Willpower';
    } else if (twoEnergyCost.includes(power)) {
      return '2 Energy';
    } else if (oneVirtueCost.includes(power)) {
      return '1 Virtue';
    } else {
      return 'Variable';
    }
  });
  
  // If all powers have the same cost, return that cost
  // Otherwise return the costs joined with commas
  const uniqueCosts = [...new Set(costs)];
  return uniqueCosts.length === 1 ? uniqueCosts[0] : costs.join(', ');
};

// Helper function to format subfaction display
const getSubfactionDisplay = (character) => {
  const subfactions = [];
  if (character.clan) subfactions.push(character.clan);
  if (character.tribe) subfactions.push(character.tribe);
  if (character.breed) subfactions.push(character.breed);
  if (character.auspice) subfactions.push(character.auspice);
  if (character.guild) subfactions.push(character.guild);
  if (character.fellowship) subfactions.push(character.fellowship);
  if (character.selectedClan) subfactions.push(character.selectedClan);
  if (character.shadowArchetype) subfactions.push(character.shadowArchetype);
  return subfactions.join(', ');
};

export const generateCharacterSheet = (character, currentVersion) => {
  return `SHADOW ACCORD CHARACTER SHEET\n\n=== BASIC INFORMATION ===\nName: ${character.name}\nPlayer: ${character.player}\nFaction: ${formatDisplayText(character.faction)}\nSubfaction: ${formatDisplayText(character.subfaction)}${character.faction === 'wraith' && character.guild ? `\nGuild: ${formatDisplayText(character.guild)}` : ''}${character.breed ? `\nBreed: ${formatDisplayText(character.breed)}` : ''}${character.auspice ? `\nAuspice: ${formatDisplayText(character.auspice)}` : ''}\nCampaign: ${character.campaign || 'None'}\nCreated: ${new Date(character.created).toLocaleDateString()}\n\n=== STATS ===\nEnergy: ${character.stats.energy}/${character.stats.maxEnergy}\nWillpower: ${character.stats.willpower}\nVirtue: ${character.stats.virtue}\nAvailable XP: ${character.totalXP}\nXP Spent: ${character.xpSpent}\nCheck-ins: ${character.checkInCount}\n\n=== SKILLS ===\n${Object.entries(character.skills).map(([skill, level]) => `${skill}: ${level}`).join('\n')}\n\n=== POWERS ===\n${Object.entries(character.powers).map(([tree, levels]) => \n  `${tree}: ${Object.keys(levels).join(', ')}`\n).join('\n')}\n\n=== MERITS ===\n${Object.entries(character.merits).map(([meritId, value]) => {\n  const merit = gameData.merits.find(m => m.merit_id === meritId);\n  const isStackable = merit?.can_purchase_multiple === 'true';\n  const displayText = isStackable && value > 1 ? `${meritId} (x${value})` : meritId;\n  return `${displayText}: ${merit?.merit_name || meritId}`;\n}).join('\n')}\n\n=== NOTES ===\n${character.notes}\n\nGenerated by Shadow Accord Character Builder v${currentVersion}\n`;
};

export const exportCharacter = async (character, format = 'json', currentVersion) => {
  const exportData = {
    character,
    exported: new Date().toISOString(),
    version: currentVersion,
    format: format
  };

  let content, filename, mimeType;

  switch (format) {
    case 'json':
      content = JSON.stringify(exportData, null, 2);
      filename = `${character.name || 'character'}_shadowaccord.json`;
      mimeType = 'application/json';
      break;
    case 'csv':
      const csvHeaders = ['Name', 'Player', 'Faction', 'Subfaction', 'Available XP', 'XP Spent'];
      const csvRow = [
        character.name, character.player, character.faction, 
        character.subfaction, character.totalXP, character.xpSpent
      ];
      content = csvHeaders.join(',') + '\n' + csvRow.join(',');
      filename = `${character.name || 'character'}_shadowaccord.csv`;
      mimeType = 'text/csv';
      break;
    case 'txt':
      content = generateCharacterSheet(character, currentVersion);
        filename = `${character.name || 'character'}_sheet.txt`;
        mimeType = 'text/plain';
      break;
    case 'pdf-debug':
      // Debug PDF export - fills all fields with their names
      (async () => {
        try {
          const templateBytes = await loadPdfFile('character-sheet-template-renamed.pdf');
          const pdfDoc = await PDFDocument.load(templateBytes);
          const form = pdfDoc.getForm();
          const fields = form.getFields();
          
          console.log('Creating debug PDF with all field names...');
          
          // Fill all text fields with their field names for debugging
          fields.forEach(field => {
            const fieldName = field.getName();
            try {
              if (field instanceof PDFTextField) {
                field.setText(fieldName);
              } else if (field instanceof PDFCheckBox) {
                // Test specific numbered checkboxes to understand layout
                if (fieldName === 'Level1-1' || fieldName === 'Level2-1' || fieldName === 'Level3-1') {
                  field.check(); // First skill's dots
                } else if (fieldName === 'Level1-2' || fieldName === 'Level2-2' || fieldName === 'Level3-2') {
                  field.check(); // Second skill's dots
                } else if (fieldName === 'Level1-3' || fieldName === 'Level2-3' || fieldName === 'Level3-3') {
                  field.check(); // Third skill's dots
                }
              }
            } catch (error) {
              console.warn(`Could not fill debug field ${fieldName}:`, error);
            }
          });
          
          const pdfBytes = await pdfDoc.save();
          await downloadFile(pdfBytes, 'debug_field_mapping.pdf', 'application/pdf');
          
          console.log('Debug PDF created! Check which skills line up with which Level checkboxes.');
        } catch (error) {
          console.error('Error creating debug PDF:', error);
          let errorMessage = 'Error generating debug PDF: ';
          
          if (error.message.includes('PDF file not found')) {
            errorMessage += 'PDF template file not found. This may be a build configuration issue.';
          } else if (error.message.includes('Failed to fetch PDF')) {
            errorMessage += 'Could not load PDF template. Check that the template file exists.';
          } else {
            errorMessage += error.message || 'Unknown error occurred.';
          }
          
          errorMessage += '\n\nRunning in: ' + (window.electronAPI?.isElectron ? 'Electron app' : 'Web browser');
          
          alert(errorMessage);
          console.error('Debug PDF Export Error Details:', {
            error: error,
            message: error.message,
            stack: error.stack,
            isElectron: window.electronAPI?.isElectron || false,
            templateFile: 'character-sheet-template-renamed.pdf'
          });
        }
      })();
      return; // Exit early since PDF export is async
    case 'pdf':
      // Handle PDF export separately - call it async
      (async () => {
        try {
          // Load the template PDF
          const templateBytes = await loadPdfFile('Shadow accord fixed fillable character sheet 7.24.pdf');
          
          // Load the PDF document
          const pdfDoc = await PDFDocument.load(templateBytes);
          const form = pdfDoc.getForm();
          
          // Debug: Log all available field names
          const fieldNames = form.getFields().map(field => field.getName());
          console.log('Available PDF fields:', fieldNames.sort());
          
          // Helper function to safely set form field
          const setFormField = (fieldName, value) => {
            try {
              const field = form.getField(fieldName);
              if (field instanceof PDFTextField) {
                field.setText(String(value || ''));
                console.log(`Set text field "${fieldName}" to "${value}"`);
              } else if (field instanceof PDFCheckBox) {
                if (value) {
                  field.check();
                  console.log(`Checked box "${fieldName}"`);
                }
              }
            } catch (error) {
              console.warn(`Could not set field ${fieldName}:`, error);
            }
          };

          // Helper function to get power cost based on power name
          const getPowerCost = (powerName) => {
            // Handle multiple powers (comma-separated)
            const powers = powerName.split(',').map(p => p.trim());
            const costs = powers.map(power => {
              // No Cost Powers (Passive/Free)
              const noCostPowers = [
                'Amaranth', 'Beast Mind', 'Bestial Frenzy', 'Black Ichor', 'Clawed Form',
                'Cloak Sight', 'Cognizance', 'Test Vitae', 'Totemic Form', 'Toughness',
                'Umbra Sight', 'Venom Blood', 'Venomous Bite', 'Visions'
              ];
              
              // 1 Energy Cost
              const oneEnergyCost = [
                'Aggravated 1', 'Aggravated Claws', 'Appear', 'Avert', 'Beast Mind',
                'Body Wrack', 'Cloak', 'Cloak Gathering', 'Light Weapon', 'Medicine', 'Root',
                'Sanctuary', 'Sense Confidence', 'Sense Demon', 'True Form',
                'Umbra Strike', 'Weaponry', 'Wither', 'Withstand', 'Woadling', 'Wounding Lies'
              ];
              
              // 1 Willpower Cost
              const oneWillpowerCost = [
                'Avoidance', 'Materialize', 'Resist Taint', 'Revive'
              ];
              
              // 2 Energy Cost
              const twoEnergyCost = [
                'Balefire', 'Blood Buff', 'Brittle Bones', 'Brutal Strike',
                'Cleanse', 'Majesty', 'Mass Taunt', 'Venom'
              ];
              
              // 1 Virtue Cost
              const oneVirtueCost = [
                'Bestial Frenzy', 'Bestial Healing'
              ];
              
              // Special cases
              if (power === 'War Form') {
                return 'Req. 1+ Energy';
              }
              if (power === 'Weaponry' && /* targeting self */ false) {
                return 'No Cost'; // Special case: Weaponry costs no Energy if targeting self
              }
              
              // Check power against cost categories
              if (noCostPowers.includes(power)) {
                return 'No Cost';
              } else if (oneEnergyCost.includes(power)) {
                return '1 Energy';
              } else if (oneWillpowerCost.includes(power)) {
                return '1 Willpower';
              } else if (twoEnergyCost.includes(power)) {
                return '2 Energy';
              } else if (oneVirtueCost.includes(power)) {
                return '1 Virtue';
              } else {
                return 'Variable';
              }
            });
            
            // If all powers have the same cost, return that cost
            // Otherwise return the costs joined with commas
            const uniqueCosts = [...new Set(costs)];
            return uniqueCosts.length === 1 ? uniqueCosts[0] : costs.join(', ');
          };

          // Helper function to format subfaction display
          const getSubfactionDisplay = (character) => {
            const subfactions = [];
            if (character.clan) subfactions.push(character.clan);
            if (character.tribe) subfactions.push(character.tribe);
            if (character.breed) subfactions.push(character.breed);
            if (character.auspice) subfactions.push(character.auspice);
            if (character.guild) subfactions.push(character.guild);
            if (character.fellowship) subfactions.push(character.fellowship);
            if (character.selectedClan) subfactions.push(character.selectedClan);
            if (character.shadowArchetype) subfactions.push(character.shadowArchetype);
            return subfactions.join(', ');
          };

          console.log('Filling PDF with character:', character);
          
          // ===== BASIC CHARACTER INFORMATION =====
          setFormField('Player Name', character.player || '');
          setFormField('Character Name', character.name || '');
          setFormField('FactionRow1', formatDisplayText(character.faction || ''));
          
          // Fill subfactions (special handling for shifters)
          if (character.faction === 'shifter') {
            // For shifters: Tribe in field 1, Breed in field 2, Auspice in field 3
            setFormField('Subfaction1', formatDisplayText(character.tribe || character.subfaction || ''));
            setFormField('Subfaction2', formatDisplayText(character.breed || ''));
            setFormField('Subfaction3', formatDisplayText(character.auspice || ''));
            console.log('Shifter subfactions:', {
              tribe: character.tribe || character.subfaction,
              breed: character.breed,
              auspice: character.auspice
            });
          } else {
            // For non-shifters: use existing logic
            const subfactions = getSubfactionDisplay(character).split(', ').filter(s => s.trim());
            console.log('Non-shifter subfactions:', subfactions);
            setFormField('Subfaction1', subfactions[0] || '');
            setFormField('Subfaction2', subfactions[1] || '');
            setFormField('Subfaction3', subfactions[2] || '');
          }
          
          // Fill advantages/weaknesses if available
          if (character.advantages) {
            const advantageLines = character.advantages.split('\n');
            advantageLines.forEach((line, index) => {
              if (index < 4) { // AdvweaknessRow1 through AdvweaknessRow4
                setFormField(`AdvweaknessRow${index + 1}`, line);
              }
            });
          }
          
          setFormField('Patron', character.patron || '');
          // Fill Gen/Rank only for shifters (rank) and vampires (generation)
          let genRankValue = '';
          if (character.faction === 'shifter' && character.rank) {
            genRankValue = character.rank;
          } else if (character.faction === 'vampire' && character.generation) {
            genRankValue = String(character.generation);
          }
          setFormField('Gen/Rank', genRankValue);
          setFormField('Passion', character.passion || '');
          
          // Fill additional character fields
          setFormField('Personal Sigil', character.sigil || '');
          setFormField('Shadow/Deed Name/Sire1', character.shadowName || character.deedName || character.sire || '');
          if (character.shadowName && character.deedName) {
            setFormField('Shadow/Deed Name/Sire2', character.deedName);
          } else if (character.shadowName && character.sire) {
            setFormField('Shadow/Deed Name/Sire2', character.sire);
          }
          
          // ===== STATS SECTION =====
          console.log('Character stats:', character.stats);
          setFormField('Health', character.stats?.health ? String(character.stats.health) : '');
          setFormField('Energy Amount', character.stats?.energy ? String(character.stats.energy) : '');
          setFormField('Energy Type', character.stats?.energyType || 'Energy');
          setFormField('Virtue', character.stats?.virtue ? String(character.stats.virtue) : '');
          setFormField('Devoured', character.stats?.devoured ? String(character.stats.devoured) : '');

          // Fill Willpower dots (WP1, WP2, etc.)
          if (character.stats?.willpower) {
            console.log(`Filling WP dots 1-${character.stats.willpower}`);
            for (let i = 1; i <= Math.min(character.stats.willpower, 10); i++) {
              setFormField(`WP${i}`, true);
            }
          }

          // Fill Virtue dots (Virtue1, Virtue2, etc.)
          if (character.stats?.virtue) {
            console.log(`Filling Virtue dots 1-${character.stats.virtue}`);
            for (let i = 1; i <= Math.min(character.stats.virtue, 10); i++) {
              setFormField(`Virtue${i}`, true);
            }
          }

          // ===== INNATE POWER TREES SECTION (Fields 1-3) =====
          console.log('=== INNATE TREES SECTION ===');
          console.log('character.innateTreeIds:', character.innateTreeIds);
          
          if (character.innateTreeIds && character.innateTreeIds.length > 0 && gameData.powerTrees) {
            character.innateTreeIds.forEach((treeId, index) => {
              if (index < 3) { // Only first 3 innate trees (fields 1-3)
                const tree = gameData.powerTrees.find(t => t.tree_id === treeId);
                if (tree) {
                  // Fill tree name in Innates fields 1-3
                  const treeFieldName = `Innates ${index + 1}`;
                  console.log(`Setting innate tree ${index + 1}: ${tree.tree_name} → ${treeFieldName}`);
                  setFormField(treeFieldName, formatDisplayText(tree.tree_name));
                  
                  // Fill power level dots if character has powers in this tree
                  if (character.powers && character.powers[treeId]) {
                    const powers = character.powers[treeId];
                    console.log(`${tree.tree_name} powers:`, powers);
                    
                    // Fill dots only for specific levels that have powers, not all previous levels
                    Object.keys(powers).forEach(level => {
                      const levelNum = parseInt(level);
                      if (levelNum >= 1 && levelNum <= 3 && powers[level]) {
                        const dotFieldName = `Level${levelNum}-${index + 1}`;
                        console.log(`Filling specific dot: ${dotFieldName} for ${tree.tree_name} level ${levelNum}`);
                        setFormField(dotFieldName, true);
                      }
                    });
                  }
                }
              }
            });
          }

          // ===== LEARNED POWER TREES SECTION (Fields 4-48) =====
          console.log('=== LEARNED TREES SECTION ===');
          
          if (character.powers && gameData.powerTrees) {
            const learnedTrees = Object.keys(character.powers).filter(treeId => 
              !character.innateTreeIds?.includes(treeId)
            );
            
            console.log('Learned trees:', learnedTrees);
            
            // First half: Fill "Learned Powers" fields (1-23) with first 23 learned trees
            learnedTrees.slice(0, 23).forEach((treeId, index) => {
              const tree = gameData.powerTrees.find(t => t.tree_id === treeId);
              const learnedFieldIndex = index + 1; // Learned Powers 1-23
              
              if (tree) {
                // Fill tree name in Learned Powers fields
                const treeFieldName = `Learned Powers ${learnedFieldIndex}`;
                console.log(`Setting learned tree (first half) ${learnedFieldIndex}: ${tree.tree_name} → ${treeFieldName}`);
                setFormField(treeFieldName, formatDisplayText(tree.tree_name));
                
                // Fill power level dots for first half (fields 4-26)
                const dotFieldIndex = learnedFieldIndex + 3; // Fields 4-26
                if (character.powers && character.powers[treeId]) {
                  const powers = character.powers[treeId];
                  console.log(`${tree.tree_name} powers (first half):`, powers);
                  
                  // Fill dots only for specific levels that have powers
                  Object.keys(powers).forEach(level => {
                    const levelNum = parseInt(level);
                    if (levelNum >= 1 && levelNum <= 3 && powers[level]) {
                      const dotFieldName = `Level${levelNum}-${dotFieldIndex}`;
                      console.log(`Filling specific learned dot (first half): ${dotFieldName} for ${tree.tree_name} level ${levelNum}`);
                      setFormField(dotFieldName, true);
                    }
                  });
                }
              }
            });
            
            // Second half: Fill Row0-Row21 fields with remaining learned trees (up to 22 more)
            learnedTrees.slice(23, 45).forEach((treeId, index) => {
              const tree = gameData.powerTrees.find(t => t.tree_id === treeId);
              if (tree) {
                const rowFieldName = `Row${index}`;
                console.log(`Setting learned tree (second half) row ${index}: ${tree.tree_name} → ${rowFieldName}`);
                setFormField(rowFieldName, formatDisplayText(tree.tree_name));
                
                // Fill power level dots for second half (fields 27-48)
                const dotFieldIndex = index + 27; // Fields 27-48
                if (character.powers && character.powers[treeId]) {
                  const powers = character.powers[treeId];
                  console.log(`${tree.tree_name} powers (second half):`, powers);
                  
                  // Fill dots only for specific levels that have powers
                  Object.keys(powers).forEach(level => {
                    const levelNum = parseInt(level);
                    if (levelNum >= 1 && levelNum <= 3 && powers[level]) {
                      const dotFieldName = `Level${levelNum}-${dotFieldIndex}`;
                      console.log(`Filling specific learned dot (second half): ${dotFieldName} for ${tree.tree_name} level ${levelNum}`);
                      setFormField(dotFieldName, true);
                    }
                  });
                }
              }
            });
          }

          // ===== SKILLS SECTION (Fields 49-63) =====
          console.log('=== SKILLS SECTION ===');
          let skillFieldIndex = 1; // Start from SkillsRow1
          
          if (character.skills && gameData.skills) {
            gameData.skills.forEach(skill => {
              const skillLevel = character.skills[skill.skill_id];
              if (skillLevel && skillFieldIndex <= 15) { // SkillsRow1-15 for skills
                const skillFieldName = `SkillsRow${skillFieldIndex}`;
                console.log(`Setting skill: ${skill.skill_name} (level ${skillLevel}) → ${skillFieldName}`);
                
                // Fill skill name
                setFormField(skillFieldName, formatDisplayText(skill.skill_name));
                
                // Fill skill level dots (fields 49-63 map to Level dots 49-63)
                const dotFieldIndex = skillFieldIndex + 48; // Fields 49-63
                for (let dotLevel = 1; dotLevel <= Math.min(skillLevel, 3); dotLevel++) {
                  const dotFieldName = `Level${dotLevel}-${dotFieldIndex}`;
                  console.log(`Filling skill dot: ${dotFieldName} for ${skill.skill_name}`);
                  setFormField(dotFieldName, true);
                }
                
                skillFieldIndex++;
              }
            });
          }

          // ===== CORRUPT POWERS CHECKBOXES (1-45 for learned powers) =====
          console.log('=== CORRUPT POWERS CHECKBOXES ===');
          
          if (character.powers && gameData.powerTrees) {
            const learnedTrees = Object.keys(character.powers).filter(treeId => 
              !character.innateTreeIds?.includes(treeId)
            );
            
            // Define corrupt/Wyrm-aligned power trees
            const corruptTrees = [
              'corruption', 'cunning', 'defiling', 'fear', 'madness_wyrm', 'strength',
              'death', 'demonology', 'daimoinon', 'dark_thaumaturgy', 'thaumaturgy_dark_path_1',
              'thaumaturgy_dark_path_2', 'thaumaturgy_dark_path_3', 'thaumaturgy_dark_path_4',
              'thaumaturgy_dark_path_5'
            ];
            
            // Map checkboxes 1-45 to learned powers (fields 4-48)
            learnedTrees.forEach((treeId, index) => {
              const checkboxIndex = index + 1; // Checkboxes 1-45
              if (checkboxIndex <= 45) { // Only use checkboxes 1-45
                const tree = gameData.powerTrees.find(t => t.tree_id === treeId);
                if (tree) {
                  // Check if this is a corrupt/Wyrm tree
                  const isCorrupt = corruptTrees.includes(treeId) || 
                                   tree.tree_name.toLowerCase().includes('wyrm') ||
                                   tree.tree_name.toLowerCase().includes('dark') ||
                                   tree.tree_name.toLowerCase().includes('corruption');
                  
                  if (isCorrupt) {
                    const checkboxFieldName = `Check Box${checkboxIndex}`;
                    console.log(`Marking corrupt power checkbox ${checkboxIndex}: ${tree.tree_name} → ${checkboxFieldName}`);
                    setFormField(checkboxFieldName, true);
                  }
                }
              }
            });
          }

          // Fill detailed powers on page 2
          // Structure: Source/Tree Name 1-33, each tree gets 3 powers (Power 1-105)
          if (character.powers && gameData.powerTrees) {
            let treeIndex = 1; // Source/Tree Name index (1-33)
            let powerIndex = 1; // Power index (1-105)
            
            Object.keys(character.powers).forEach(treeId => {
              const tree = gameData.powerTrees.find(t => t.tree_id === treeId);
              if (tree && treeIndex <= 33) {
                const powers = character.powers[treeId];
                
                // Fill tree name in Source/Tree Name field (remove "Gift" from name)
                const cleanTreeName = tree.tree_name.replace(/\s*Gift\s*/i, '').trim();
                setFormField(`Source/Tree Name ${treeIndex}`, formatDisplayText(cleanTreeName));
                console.log(`Setting Source/Tree Name ${treeIndex}: ${cleanTreeName} (original: ${tree.tree_name})`);
                
                // Fill exactly 3 powers for this tree (levels 1, 2, 3)
                for (let level = 1; level <= 3; level++) {
                  if (powerIndex <= 105) { // Don't exceed Power 105
                    let powerName = '';
                    
                    // Check if character has this power level
                    if (powers[level]) {
                      // Get the power names for this level from the tree data
                      const levelPowersString = tree[`level${level}_powers`];
                      if (levelPowersString) {
                        // Split pipe-delimited power names and join them
                        const levelPowers = levelPowersString.split('|').filter(p => p.trim());
                        powerName = levelPowers.join(', '); // Join multiple powers with commas
                      } else {
                        // Fallback: generate power name from tree and level
                        powerName = `${tree.tree_name} ${level}`;
                      }
                    }
                    
                    setFormField(`Power ${powerIndex}`, powerName);
                    
                    // Set power cost based on power name
                    let powerCost = '';
                    if (powerName) {
                      powerCost = getPowerCost(powerName);
                    }
                    setFormField(`Cost ${powerIndex}`, powerCost);
                    
                    console.log(`Setting Power ${powerIndex}: "${powerName}" for ${tree.tree_name} level ${level} (has power: ${!!powers[level]})`);
                    powerIndex++;
                  }
                }
                
                treeIndex++;
              }
            });
          }

          // Fill merits using correct field names
          if (character.merits && gameData.merits) {
            let meritIndex = 1;
            console.log('Filling merits, character.merits:', character.merits);
            Object.keys(character.merits).forEach(meritId => {
              const merit = gameData.merits.find(m => m.merit_id === meritId);
              if (merit && meritIndex <= 8) {
                const meritValue = character.merits[meritId];
                console.log('Processing merit:', merit, 'value:', meritValue);
                // Ensure merit name is safe to format
                const meritName = merit.merit_name || merit.name || `Merit ${meritId}`;
                const meritText = formatDisplayText(meritName);
                setFormField(`Merit${meritIndex}`, meritText);
                meritIndex++;
              }
            });
          }

          // Fill lores using correct field names
          if (character.lores && character.lores.length > 0) {
            console.log('Filling lores:', character.lores);
            // Available lore fields: " Lore Row1-7" (with leading space), "Lore Row8-15" (no space)
            const loreFields = [
              ' Lore Row1', ' Lore Row2', ' Lore Row3', ' Lore Row4', ' Lore Row5', ' Lore Row6', ' Lore Row7',
              'Lore Row8', 'Lore Row9', 'Lore Row10', 'Lore Row11', 'Lore Row12', 'Lore Row13', 'Lore Row14', 'Lore Row15'
            ];
            
            character.lores.forEach((lore, index) => {
              if (index < loreFields.length) {
                const loreField = loreFields[index];
                // Handle different lore data structures
                let loreName = '';
                if (typeof lore === 'string') {
                  loreName = lore;
                } else if (typeof lore === 'object' && lore !== null) {
                  // Try to get name from the object
                  loreName = lore.name || lore.lore_name || lore.title || '';
                  
                  // If no name found but has lore_id, try to look up from game data
                  if (!loreName && lore.lore_id && gameData.lores) {
                    const loreData = gameData.lores.find(l => l.lore_id === lore.lore_id);
                    loreName = loreData ? (loreData.lore_name || loreData.name || '') : lore.lore_id;
                  }
                  
                  // Fallback to lore_id if still no name
                  if (!loreName && lore.lore_id) {
                    loreName = lore.lore_id.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                  }
                }
                console.log(`Setting lore field "${loreField}" to "${formatDisplayText(loreName)}" (from:`, lore, ')');
                setFormField(loreField, formatDisplayText(loreName));
              }
            });
          }

          // Fill notes using correct field names
          if (character.notes) {
            const noteLines = character.notes.split('\n');
            noteLines.forEach((line, index) => {
              if (index < 6) { // Attunement  NotesRow1 through Attunement  NotesRow6
                setFormField(`Attunement  NotesRow${index + 1}`, line);
              }
            });
          }

          // Generate and download the filled PDF
          const pdfBytes = await pdfDoc.save();
          await downloadFile(pdfBytes, `${character.name || 'character'}_shadowaccord_sheet.pdf`, 'application/pdf');
          
        } catch (error) {
          console.error('Error exporting to PDF:', error);
          let errorMessage = 'Error generating PDF: ';
          
          if (error.message.includes('PDF file not found')) {
            errorMessage += 'PDF template file not found. This may be a build configuration issue.';
          } else if (error.message.includes('Failed to fetch PDF')) {
            errorMessage += 'Could not load PDF template. Check that the template file exists.';
          } else if (error.message.includes('No PDF header found')) {
            errorMessage += 'Invalid PDF template file.';
          } else {
            errorMessage += error.message || 'Unknown error occurred.';
          }
          
          errorMessage += '\n\nRunning in: ' + (window.electronAPI?.isElectron ? 'Electron app' : 'Web browser');
          
          alert(errorMessage);
          console.error('PDF Export Error Details:', {
            error: error,
            message: error.message,
            stack: error.stack,
            isElectron: window.electronAPI?.isElectron || false,
            templateFile: 'Shadow accord fixed fillable character sheet 7.24.pdf'
          });
        }
      })();
      return; // Exit early since PDF export is async
    default:
      content = JSON.stringify(exportData, null, 2);
      filename = `${character.name || 'character'}_shadowaccord.json`;
      mimeType = 'application/json';
  }

  const blob = new Blob([content], { type: mimeType });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
};